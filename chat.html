<!DOCTYPE html>
<html>
<head>
  <title>Spectrogram Viewer (Scaled to Data)</title>
</head>
<body>
  <h2>Paste Your PCM Data (column or row):</h2>
  <textarea id="dataInput" rows="10" cols="80"></textarea><br>
  <button onclick="plotSpectrogram()">Plot Spectrogram</button>
  <canvas id="spectrogramCanvas" width="800" height="400" style="border:1px solid #ccc"></canvas>

  <script>
    function plotSpectrogram() {
      const canvas = document.getElementById('spectrogramCanvas');
      const ctx = canvas.getContext('2d');
      const dataStr = document.getElementById('dataInput').value;

      // Parse input data (handle spaces, commas, or new lines)
      let samples = dataStr
        .trim()
        .split(/[\s,]+|\r?\n/)
        .map(Number)
        .filter(n => !isNaN(n));

      // Normalize to max amplitude 1
      const maxVal = Math.max(...samples.map(Math.abs)) || 1;
      samples = samples.map(s => s / maxVal);

      const fftSize = 256;
      const hopSize = fftSize / 2;
      const sampleRate = 44100;

      function hannWindow(n) {
        return Array.from({ length: n }, (_, i) => 0.5 * (1 - Math.cos((2 * Math.PI * i) / (n - 1))));
      }

      // Naive DFT (for demo, slow but okay for 256 samples)
      function fft(input) {
        const N = input.length;
        const real = new Float32Array(N);
        const imag = new Float32Array(N);
        for (let k = 0; k < N; k++) {
          for (let n = 0; n < N; n++) {
            real[k] += input[n] * Math.cos((2 * Math.PI * k * n) / N);
            imag[k] -= input[n] * Math.sin((2 * Math.PI * k * n) / N);
          }
        }
        return real.map((r, i) => Math.sqrt(r * r + imag[i] * imag[i]));
      }

      // Clear canvas
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const window = hannWindow(fftSize);
      const frameCount = Math.floor((samples.length - fftSize) / hopSize);
      if (frameCount <= 0) {
        alert('Not enough data for FFT. Need at least ' + fftSize + ' samples.');
        return;
      }

      for (let x = 0; x < frameCount; x++) {
        const i = x * hopSize;
        const frame = samples.slice(i, i + fftSize);
        const windowed = frame.map((v, j) => v * window[j]);
        const mag = fft(windowed).slice(0, fftSize / 2);

        // Map the slice index x to canvas width (stretch)
        const px = Math.floor((x / frameCount) * canvas.width);

        for (let y = 0; y < mag.length; y++) {
          const dB = 20 * Math.log10(mag[y] + 1e-6);
          const dBClamped = Math.max(-80, Math.min(0, dB));
          const brightness = Math.round(255 * (dBClamped + 80) / 80);
          ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;

          const py = canvas.height - (y / mag.length) * canvas.height;
          ctx.fillRect(px, py, 1, 1);
        }
      }
    }
  </script>
</body>
</html>
